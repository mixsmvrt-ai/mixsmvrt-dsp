import json
from dataclasses import asdict

from fastapi import FastAPI, UploadFile, File, Form, Query, HTTPException
from fastapi.middleware.cors import CORSMiddleware

from app.engine import process_audio
from app.analysis import analyze_audio
from app.preset_registry import list_presets

app = FastAPI(title="MixSmvrt DSP Engine")

# Allow the Vercel studio and local development to call this DSP service
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://mixsmvrt.vercel.app",
        "http://localhost:3000",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/health")
async def health():
    """Lightweight health endpoint for uptime checks.

    Returns a static JSON payload so Render and external monitors can verify
    that the DSP service is up without exercising the full processing stack.
    """

    return {"status": "ok"}


@app.post("/analyze")
async def analyze(file: UploadFile = File(...)):
    """Return analysis stats and reference-based preset overrides."""
    return analyze_audio(file)


@app.post("/process")
async def process(
    file: UploadFile = File(...),
    track_type: str = Form("vocal"),
    preset: str = Form("clean_vocal"),
    genre: str | None = Form(None),
    reference_profile: str | None = Form(None),
    target: str | None = Form(None),
    gender: str | None = Form(None),
    throw_fx_mode: str | None = Form(None),
    session_key: str | None = Form(None),
    session_scale: str | None = Form(None),
    plugin_chain: str | None = Form(None),
):
    """Process an uploaded audio file with the given track type + preset.

    Optionally accepts a ``reference_profile`` JSON string containing
    ``preset_overrides`` generated by the /analyze endpoint.
    """

    overrides_dict = None
    if reference_profile:
        try:
            parsed = json.loads(reference_profile)
            # Frontend typically passes the ``preset_overrides`` object.
            overrides_dict = parsed.get("preset_overrides", parsed)
        except Exception:  # pragma: no cover - defensive parsing
            overrides_dict = None

    plugin_chain_overrides = None
    if plugin_chain:
        try:
            plugin_chain_overrides = json.loads(plugin_chain)
        except Exception:  # pragma: no cover - defensive parsing
            plugin_chain_overrides = None

    try:
        output_paths = process_audio(
            file,
            track_type,
            preset,
            genre,
            gender,
            overrides_dict,
            target,
            throw_fx_mode=throw_fx_mode,
            session_key=session_key,
            session_scale=session_scale,
            plugin_chain=plugin_chain_overrides,
        )
    except Exception as exc:  # pragma: no cover - defensive, logs via HTTP detail
        # Surface a more descriptive error than the default "Internal Server Error"
        # so upstream services and the studio UI can see what went wrong.
        raise HTTPException(status_code=500, detail=f"DSP processing failed: {exc}") from exc
    # Normalise outputs so callers always have a primary output_file (WAV)
    # while also exposing a richer output_files map for multi-format exports.
    if isinstance(output_paths, dict):
        wav_path = output_paths.get("wav")
        mp3_path = output_paths.get("mp3")
    else:  # backwards-compat: older engine versions may return a single string
        wav_path = output_paths
        mp3_path = None

    return {
        "status": "processed",
        # Primary output remains the WAV path for backwards compatibility.
        "output_file": wav_path,
        # New multi-format map used by the studio for WAV/MP3 downloads.
        "output_files": {
            "wav": wav_path,
            "mp3": mp3_path,
        },
        "track_type": track_type,
        "preset": preset,
        "genre": genre,
        "gender": gender,
    }


@app.get("/presets")
async def list_available_presets(kind: str | None = Query(default=None)):
    """Return the catalog of presets known to the DSP engine.

    Optional query parameter ``kind`` can be one of ``vocal``, ``mix`` or
    ``master`` to filter the list. The response is structured for direct
    consumption by the studio or admin UI.
    """

    normalized: str | None
    if kind in {"vocal", "mix", "master"}:
        normalized = kind
    else:
        normalized = None

    presets = list_presets(kind=normalized)  # type: ignore[arg-type]
    return {
        "presets": [asdict(p) for p in presets],
    }
